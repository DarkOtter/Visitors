package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"log"
	"os"
	"path"
	"regexp"
	"slices"
	"strconv"
	"strings"

	"golang.org/x/tools/go/packages"
)

func writeCode(target string, source []byte) error {
	fmt_source, err := format.Source(source)
	if err != nil {
		// This probably means that the source code is not actually valid, so keep it unformatted
		fmt_source = source
	}
	return os.WriteFile(target, fmt_source, 0644)
}

func bprintf(buffer *bytes.Buffer, format string, args ...interface{}) {
	_, err := fmt.Fprintf(buffer, format, args...)
	if err != nil {
		panic(fmt.Errorf("BUG: writing to a bytes.Buffer should never fail but it did: %w", err))
	}
}

type generateJob struct {
	InterfaceName string
	TypeNames     *regexp.Regexp
}

func (g *generateJob) String() string {
	return fmt.Sprintf("%s:%s", g.InterfaceName, g.TypeNames)
}

type generateJobFlags []generateJob

func (g *generateJobFlags) String() string {
	var parts []string
	for _, job := range *g {
		parts = append(parts, job.String())
	}
	return strings.Join(parts, ", ")
}

func (g *generateJobFlags) Set(value string) error {
	namePart := value
	var regexPart string
	if splitIndex := strings.Index(value, ":"); splitIndex >= 0 {
		namePart = value[:splitIndex]
		regexPart = value[splitIndex+1:]
	} else {
		regexPart = fmt.Sprintf("^[A-Z].*%s$", regexp.QuoteMeta(namePart))
	}
	if namePart == "" {
		return fmt.Errorf("invalid interace name: cannot be empty")
	}
	regex, err := regexp.Compile(regexPart)
	if err != nil {
		return fmt.Errorf("invalid regex: %w", err)
	}
	*g = append(*g, generateJob{InterfaceName: namePart, TypeNames: regex})
	return nil
}

func approxFormatCommandLine(items []string) string {
	var result strings.Builder
	safeRegex, err := regexp.Compile("^[\\-a-zA-Z_0-9:;@Â£*~/.,?=+]+$")
	if err != nil {
		panic(fmt.Errorf("BUG: invalid regex: %w", err))
	}
	for index, item := range items {
		if index > 0 {
			result.WriteString(" ")
		}
		if safeRegex.MatchString(item) {
			result.WriteString(item)
		} else if strings.Contains(item, "'") {
			result.WriteString(strconv.Quote(item))
		} else {
			_, err := fmt.Fprintf(&result, "'%s'", item)
			if err != nil {
				panic(fmt.Errorf("BUG: writing to a string builder should never fail but it did: %w", err))
			}
		}
	}
	return result.String()
}

func main() {
	flag.Usage = func() {
		if _, err := fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s -o OUTPUT_FILE -generate INTERFACE PACKAGE_PATTERN\n", path.Base(os.Args[0])); err != nil {
			panic(err)
		}
		flag.PrintDefaults()
	}

	var jobs generateJobFlags
	flag.Var(&jobs, "generate", "A visitor interface to generate. The format is <interface name>:<regex for type names>, which can be abbreviated to just <interface name> if the regex is just to have the interface name as a interfaceName.")
	generatePackageName := flag.String("package", "", "The name of the package to put the generated code in.")
	outputFileName := flag.String("o", "", "The name of the file to write the generated code to.")
	flag.Parse()
	if *outputFileName == "" {
		log.Fatalf("output file name must be specified")
	}
	args := flag.Args()
	if len(args) != 1 {
		_, err := fmt.Fprintf(flag.CommandLine.Output(), "Expected exactly one package pattern as argument\n")
		if err != nil {
			panic(err)
		}
		flag.Usage()
		os.Exit(1)
	}
	packagePattern := args[0]

	cfg := &packages.Config{Mode: packages.NeedTypes}
	pkgs, err := packages.Load(cfg, packagePattern)
	if err != nil {
		log.Fatalf("failed to load packages: %v", err)
	} else if len(pkgs) != 1 {
		names := make([]string, len(pkgs))
		for _, pkg := range pkgs {
			names = append(names, pkg.ID)
		}
		log.Fatalf("expected one package, got: %s", strings.Join(names, ", "))
	}
	pkg := pkgs[0]
	if len(pkg.Types.Scope().Names()) == 0 {
		log.Fatalf("expected at least one type but package %s has none", pkg.ID)
	}
	if *generatePackageName == "" {
		*generatePackageName = path.Base(pkg.ID)
	}

	scope := pkg.Types.Scope()

	groupedTypes := make(map[string][]*types.TypeName)
	for _, job := range jobs {
		groupedTypes[job.InterfaceName] = make([]*types.TypeName, 0, 8)
	}

perNameLoop:
	for _, name := range scope.Names() {
		obj := scope.Lookup(name)
		if obj == nil {
			panic("BUG: nil object for name")
		}
		if obj, ok := obj.(*types.TypeName); ok {
			for _, job := range jobs {
				if name == job.InterfaceName {
					continue perNameLoop
				}
			}
			var foundInterface string
			for _, job := range jobs {
				if job.TypeNames.MatchString(name) {
					foundInterface = job.InterfaceName
				}
			}
			if foundInterface == "" {
				continue perNameLoop
			}
			groupedTypes[foundInterface] = append(groupedTypes[foundInterface], obj)
		}
	}

	var buf bytes.Buffer

	bprintf(&buf, "// Code generated by %s; DO NOT EDIT.\n\n", approxFormatCommandLine(slices.Concat(
		[]string{path.Base(os.Args[0])},
		os.Args[1:])))
	bprintf(&buf, "package %s\n\n", *generatePackageName)

	for interfaceName, typesForInterface := range groupedTypes {
		if len(typesForInterface) == 0 {
			continue
		}
		visitorName := fmt.Sprintf("%sVisitor", interfaceName)
		bprintf(&buf, "type %s interface {\n", visitorName)
		for _, suffixType := range typesForInterface {
			name := suffixType.Name()
			bprintf(&buf, "\tVisit%s(expr *%s)\n", name, name)
		}
		bprintf(&buf, "}\n\n")

		bprintf(&buf, "type %s interface {\n", interfaceName)
		bprintf(&buf, "\tAccept(visitor %s)\n", visitorName)
		bprintf(&buf, "}\n\n")

		for _, suffixType := range typesForInterface {
			name := suffixType.Name()
			bprintf(&buf, "func (expr *%s) Accept(visitor %s) {\n", name, visitorName)
			bprintf(&buf, "\tvisitor.Visit%s(expr)\n", name)
			bprintf(&buf, "}\n\n")
		}
	}

	err = writeCode(*outputFileName, buf.Bytes())
	if err != nil {
		log.Fatalf("failed to write code to file: %v", err)
	}
}
